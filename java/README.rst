#####################
GRPC-Java OpenTracing
#####################

============
Installation
============

This package is available on Maven Central and can be added to your project as follows:

**Maven**

.. code-block::

	<dependencies>
		<dependency>
			<groupId>io.opentracing.contrib.grpc</groupId>
			<artifactId>grpc-opentracing</artifactId>
			<version>0.1.0</version>
		</dependency>
	</dependencies>

**Gradle**

.. code-block::
	
	compile 'io.opentracing.contrib.grpc:grpc-opentracing:0.1.0'

==========
Quickstart
========== 

If you want to add basic tracing to your clients and servers, you can do so in a few short and simple steps, as shown below. (These code snippets use the grpc example's `GreeterGrpc`, generated by protocol buffers.)

**Servers**

- Instantiate a tracer
- Create a `ServerTracingInterceptor`
- Intercept a service 
    
.. code-block:: java

    public class YourServer {

        private int port;
        private Server server;

        private void start() throws IOException {
        
            Tracer tracer = yourOpenTracingTracer;
            ServerTracingInterceptor tracingInterceptor = new ServerTracingInterceptor(tracer);

            server = ServerBuilder.forPort(port)
                .addService(tracingInterceptor.intercept(someServiceDef))
                .build()
                .start();
        }
    }

**Clients**

- Instantiate a tracer
- Create a `ClientTracingInterceptor`
- Intercept the client channel

.. code-block:: java

	public class YourClient {

		private final ManagedChannel channel;
  		private final GreeterGrpc.GreeterBlockingStub blockingStub;

		public YourClient(String host, int port) {

			channel = ManagedChannelBuilder.forAddress(host, port)
				.usePlaintext(true)
				.build();
		
			Tracer tracer = yourOpenTracingTracer;
			ClientTracingInterceptor tracingInterceptor = new ClientTracingInterceptor(tracer)

			blockingStub = GreeterGrpc.newBlockingStub(tracingInterceptor.intercept(channel));
		}
	}

==============
Server Tracing
==============

A `ServerTracingInterceptor` uses default settings, which you can override by creating it using a `ServerTracingInterceptor.Builder`.

- `withOperationName(String operationName)`: Sets the operation name for all spans created for the intercepted service. Default is the name of the RPC method.
- `withStreaming()`: Logs to the server span whenever a message is received.
- `withVerbosity()`: Logs to the server span additional events, such as message received, half close (client finished sending messages), and call complete. Default only logs if a call is cancelled.  
- `withTracedAttributes(ServerRequestAttribute... attrs)`: Sets tags on the server span in case you want to track information about the RPC call. See ServerRequestAttribute.java for a list of traceable request attributes.

**Example**:

.. code-block:: java

    ServerTracingInterceptor tracingInterceptor = new ServerTracingInterceptor
        .Builder(tracer)
        .withStreaming()
        .withVerbosity()
        .withOperationName("service-name")
        .withTracedAttributes(ServerRequestAttribute.HEADERS, 
            ServerRequestAttribute.METHOD_TYPE)
        .build();

==============
Client Tracing
==============

A `ClientTracingInterceptor` also has default settings, which you can override by creating it using a `ServerTracingInterceptor.Builder`.

- `withOperationName(String operationName)`: Sets the operation name for all spans created for this intercepted client. Default is the name of the RPC method.
- `withStreaming()`: Logs to the client span whenever a message is sent or a response is received.
- `withVerbosity()`: Logs to the client span additional events, such as call started, message sent, half close (client finished sending messages), response received, and call complete. Default only logs if a call is cancelled.  
- `withTracedAttributes(ClientRequestAttribute... attrs)`: Sets tags on the client span in case you want to track information about the RPC call. See ClientRequestAttribute.java for a list of traceable request attributes.

**Example**:

.. code-block:: java

    ClientTracingInterceptor tracingInterceptor = new ClientTracingInterceptor
        .Builder(tracer)
        .withStreaming()
        .withVerbosity()
        .withOperationName("client-name")
        .withTracingAttributes(ClientRequestAttribute.ALL_CALL_OPTIONS,
            ClientRequestAttribute.HEADERS)
        .build();

====================
Current Span Context
====================

In your server request handler, you can access the current active span for that request by calling

.. code-block:: java

    Span span = OpenTracingContextKey.activeSpan();

This is useful if you want to manually set tags on the span, log important events, or create a new child span for internal units of work. You can actually use this key to wrap these internal units of work with a new context that has a user-defined active span.

For example:

.. code-block:: java

    Tracer tracer = someOpenTracingTracer;

    // some unit of internal work that you want to trace
    Runnable internalWork = new Runnable() {
        public void run() {
            // do some work
        }
    } 

    // get the active span 
    Span activeSpan = OpenTracingContextKey.activeSpan();

    // create a child span to represent the internal work
    Span childSpan = tracer.buildSpan("internal-work").asChildOf(activeSpan).start();

    // define a new context with childSpan as the active span
    Context contextWithChildSpan = Context.current().withValue(OpenTracingContextKey.get(), childSpan);

    // wrap the internal work with this new context so that the active span in the scope 
    // of internalWork is childSpan
    Runnable tracedInternalWork = contextWithChildSpan.wrap(internalWork)
    tracedInternalWork.run()

    // make sure to finish any manually created spans!
    childSpan.finish();

Continuing a Trace
------------------

Sometimes you may have a client that is created within the scope of a service. If this service is traced, and there is an active span present in `Context.current()`, then the ClientTracingInterceptor will recognize the active span and continue the current trace automatically.

===================================
Integrating with Other Interceptors
===================================

Although we provide ServerTracingInterceptor.intercept(service) and ClientTracingInterceptor.intercept(channel) methods, you don't want to use these if you're chaining multiple interceptors. Instead, use the following code (preferably putting the tracing interceptor at the top of the interceptor stack so that it traces the entire request lifecycle, including other interceptors):

**Servers**

.. code-block:: java

    server = ServerBuilder.forPort(port)
        .addService(ServerInterceptors.intercept(service, someInterceptor, 
            someOtherInterceptor, serverTracingInterceptor))
        .build()
        .start();

**Clients**

.. code-block:: java

    blockingStub = GreeterGrpc.newBlockingStub(ClientInterceptors.intercept(channel,
        someInterceptor, someOtherInterceptor, clientTracingInterceptor));
